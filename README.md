# Private-key-Cryptosystem-using-Subfield-Subcode
# （間違えたら消します）

部分体部分符号を用いたエラー入り公開鍵暗号とその実装


20201007：

・課題その２　エラー入りMcEliece暗号（設計中）

設定：[n,k,d]=[640,320,65]-binary Goppa Code。

ここで、t=32とする。

1.E=SGPとする。

２，Eの後半n-k個の異なる列に重み１のエラーを加える。Eの次元は320なのでその組み合わせは320C32になる。
E'=Σ(e_i^E_i)(0<i<k)とする。

3．暗号化鍵E'の各行のどの位置にダミーのエラーe_iが入っているか、暗号文作成者は知っている。


目的としているセキュリティパラメータは１２８ビットである。（目標）

２５６ビット以上のセキュリティを実現したい場合は、符号長を１０２４にしなければならないだろう。（予想）


その１

暗号化：（ISDを理解してない）

１．乱数rをwt(r)+wt(m)=t,|r|=kとする。暗号文をc=rE'+mとする。

ここで、wt(m)<t,0<wt(r)=<tである。wt(r)>0なのは符号語が消えないため。

２．（暗号化フォーマット）平文ｍはwt(m)<t,|m|=kだが、mは左詰めとし、ｍの最後の１が立っている位置で平文ブロックを切ることとする。(残りは０で埋める)


復号化：

1.wt(r)+wt(m)=tより、暗号文ｃに対してシンドロームs=cHを計算する。

2.D_k(s)=e

3.wt(e)=tなので、前半ｋビットが平文である。



その２：(１とほぼ同じ)

設定：

１，[n,k,d]=[640,320,65]-バイナリGoppa Codeを考える。
ここで、訂正可能なエラーベクトルwt(t)=32とする。
更にパリティ検査行列のパラメータは[n,k]=[640,320]である。

２．暗号化鍵をE=SGPとして、S,G,Pは秘密鍵である。

３．Eの前半ｋビットをＡ、後半n-kビットをＢとする。Ｂの異なる全ての列iに重み1のエラーe_iが１か所づつ、ランダムに混入されているものとする。 
エラーe_iが入った暗号化鍵をE'とする。

つまり、乱数ｒをwt(r)=tとすると、c=rE'には必ず重みtのダミーエラーパターンe'=Σe_i,k<i<nが入っていることになる。


暗号化：

１平文mを|m|=k、wt(m)=<tとなるようにとり、ランダムエラーベクトルrをwt(m)+wt(r)=tとなるようにとる。(mは０でもいい)
また、|m|<kのばあい、mの最後の1以降を０でパディングする。

２．暗号文c=mE'+rとする。
エラーベクトルrは、E'の前半kビットに入れる。

３.暗号化鍵E'のmに対するダミーエラーからできたエラーパターンをe'とすると、cに含まれるエラーはr+e'。
ここで、wt(r+e')=t.


復号：

1．cH=s

2.D(s)=r^e'

3.m'=c^(r^e')とし、m=m"A^{-1}。

ここで、E'の次元をｋとすると、ｍ’の前半ｋビットをm",E'の前半ｋ＊ｋ行列をＡとする。



20201006

・課題その１　Rao-Nam型秘密鍵暗号の安全性の下界を比較してみる。


暗号化鍵が見えなければいいので、鍵サイズも公開鍵バージョンよりずっと小さくなる。

その代わりRao-Nam暗号より鍵がでかい。

そしてシンドロームエラーテーブルも使わない。

この場合、選択平分攻撃は、暗号化鍵をブラックボックスとして、ひたすら平文とそれに対応する暗号文を集める差分攻撃になる。

この時、暗号解読に必要となる平文と暗号文のデータを、すべて集めるのが物理的に不可能な時間とサイズを見積もることで、 この手の秘密鍵暗号の様々なバリエーションに、秘密鍵サイズに応じた、安全性に対する一つの下界を算出することができるだろう。

ここでちょっとはみ出してみると、ハミング重み＝最小距離d-1のエラーを混ぜた時、２つの過剰なd-1重みのエラーベクトルの シンドローム衝突を見つける難しさに基づいてハッシュ関数も作れそうなお感がする。

ハッシュ関数の設計に符号理論の結果を使うほうが、無理に死にかけた秘密鍵暗号を組成するよりまともかもしれないが、 それはまた別の研究テーマになる。

ある秘密鍵暗号の試論

公開パラメータ：n=1024,k=32＊10=320,secret key size 320bit(必要なら+320＊320+10＊1024=112960bit),wt(r)=32(r is random error)

暗号化：

1.input m;

2.output randomization c=(H(r)^m,rH);wt(r)=32

PACEではシンドロームエラーテーブルと暗号化行列の両方が秘密鍵であり、暗号化するときも復号するときも同じ鍵を使う。（多分これは普通）

秘密鍵マックリース暗号では、暗号化にゴッパ多項式から生成されるパリティ検査行列を使い、 秘密鍵にゴッパ多項式と復号アルゴリズムにパターソンアルゴリズムを使う。

エラーテーブルは使わない。

ということは毎回秘密鍵から暗号化行列を生成することになり、カギ生成のオーバーヘッドが問題になる。

なんでこんなことをするかというと、単純に、ナードっぽく1つの平文に対して集めきれないほど大きな暗号文が生成されることを狙っているからだ。

参考文献によると、PACE解読にかかる計算量はO(k^2nN^2)であるが、実はこのN(１つの選択平文に対する、可能な全ての暗号文の数)というのは指数的である。

なのでこのNが途轍もなく大きければ計算できないことになる、というのが私の論文の趣旨であった。 実際エラーテーブルを使ってこのＮを大きくしようとすると、秘密鍵サイズも膨大に増えてしまって改良にならない。

そこで、エラーテーブルを使わないで普通に訂正できる範囲内で暗号化復号化できるようにしようという感じで、秘密鍵マクリースは生まれた。 そしてそのようなパラメータとしてn=8192、k=3328を選んだ。（でかすぎｗ）

このパラメータは正しくないと思うのだが、折角だから修論補完計画としてやってみよう。（予定）

そしてＰＡＣＥっぽく、エラーテーブルの代わりに、最初から暗号化鍵にエラーを混入させておくタイプの暗号方式が可能かどうかやってみよう。 これは例えば、ニーダーライターではなくマックリースだけに言えるのだが、暗号化行列は符号の生成行列であると同時に、 カギ自体が符号語であるということを利用する。

＊　PACE：Rao-Nam Scheme　＊

１．秘密鍵：ハミング距離=3であるような簡単な符号、ハミング重みｔ=n/2である幾つかの過剰なエラーパターンzとそのシンドロームとの対応表をシンドローム・エラーテーブルZと呼ぶ。

２．暗号化：

G'=SG

c=(mSG+e)P

３．復号：

c=(mSG+e)P=mSGP+eP

c'=cP=mSG+e

c'H=s

Z(s)=e

a=c'^e=c=mSG

a(SG)^{-1}=m

・選択的平文攻撃にかかる計算量O(k^2nN^2logN),n符号長、ｋ符号の次元、Ｎ平文と暗号文のペアの数。（このＮは実はnに対して指数関数になる）

参考文献：THE RAO-NAM SCHEME IS INSECURE AGAINST A CHOSEN-PLAINTEXT ATTACK

https://link.springer.com/chapter/10.1007/3-540-48184-2_40

