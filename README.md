# Pubric-key-Cryptosystem-using-Subfield-Subcode(with Hidden error pattern)
# （間違えたら消します）


部分体部分符号を用いたエラー入り公開鍵暗号とその実装

20201008

逆にこう言える。
好きな場所にエラーが入れられるということは、一見乱数を暗号化しているように見えて、符号に含まれるエラーを用いて任意のメッセージを復号時に再現できるということを意味している。

もしそうなら、後半部分に公開鍵に含まれるエラーを使って真の伝達分を構成するのと同時に、
前半部分のwt(m)+wt(e)=tのeをランダムにすることで、あたかも乱数をやり取りしているように見せることができる。


20201007

そしてＰＡＣＥっぽく、エラーテーブルの代わりに、最初から暗号化鍵にエラーを混入させておくタイプの暗号方式が可能かどうかやってみよう。 これは例えば、ニーダーライターではなくマックリースだけに言えるのだが、暗号化行列は符号の生成行列であると同時に、 カギ自体が符号語であるということを利用する。
秘密鍵マックリース暗号では、暗号化にゴッパ多項式から生成されるパリティ検査行列を使い、 秘密鍵にゴッパ多項式と復号アルゴリズムにパターソンアルゴリズムを使う。

エラーテーブルは使わない。

ということは毎回秘密鍵から暗号化行列を生成することになり、カギ生成のオーバーヘッドが問題になる。

20201007：

・課題その２　エラー入りMcEliece暗号（設計中）

設定：[n,k,d]=[640,320,65]-binary Goppa Code。

ここで、t=32とする。

1.E=SGPとする。

２，Eの後半n-k個の異なる列に重み１のエラーを加える。Eの次元は320なのでその組み合わせは320C32になる。
E'=Σ(e_i^E_i)(0<i<k)とする。

3．暗号化鍵E'の各行のどの位置にダミーのエラーe_iが入っているか、暗号文作成者は知っている。


目的としているセキュリティパラメータは１２８ビットである。（目標）

２５６ビット以上のセキュリティを実現したい場合は、符号長を１０２４にしなければならないだろう。（予想）


その１

暗号化：（ISDを理解してない）

１．乱数rをwt(r)+wt(m)=t,|r|=kとする。暗号文をc=rE'+mとする。

ここで、wt(m)<t,0<wt(r)=<tである。wt(r)>0なのは符号語が消えないため。

２．（暗号化フォーマット）平文ｍはwt(m)<t,|m|=kだが、mは左詰めとし、ｍの最後の１が立っている位置で平文ブロックを切ることとする。(残りは０で埋める)


復号化：

1.wt(r)+wt(m)=tより、暗号文ｃに対してシンドロームs=cHを計算する。

2.D_k(s)=e

3.wt(e)=tなので、前半ｋビットが平文である。



その２：(１とほぼ同じ)

設定：

１，[n,k,d]=[640,320,65]-バイナリGoppa Codeを考える。
ここで、訂正可能なエラーベクトルwt(t)=32とする。
更にパリティ検査行列のパラメータは[n,k]=[640,320]である。

２．暗号化鍵をE=SGPとして、S,G,Pは秘密鍵である。

３．Eの前半ｋビットをＡ、後半n-kビットをＢとする。Ｂの異なる全ての列iに重み1のエラーe_iが１か所づつ、ランダムに混入されているものとする。 
エラーe_iが入った暗号化鍵をE'とする。

つまり、乱数ｒをwt(r)=tとすると、c=rE'には必ず重みtのダミーエラーパターンe'=Σe_(i,j),k<i<n,0<j<kが入っていることになる。


暗号化：

１平文mを|m|=k、wt(m)=<tとなるようにとり、ランダムエラーベクトルrをwt(m)+wt(r)=tとなるようにとる。(mは０でもいい)
また、|m|<kのばあい、mの最後の1以降を０でパディングする。

２．暗号文c=mE'+rとする。
エラーベクトルrは、E'の前半kビットに入れる。

３.暗号化鍵E'のmに対するダミーエラーからできたエラーパターンをe'とすると、cに含まれるエラーはr+e'。
ここで、wt(r+e')=t.


復号：

1．cH=s

2.D(s)=r^e'

3.m'=c^(r^e')とし、m=m"A^{-1}。

ここで、E'の次元をｋとすると、ｍ’の前半ｋビットをm",E'の前半ｋ＊ｋ行列をＡとする。

